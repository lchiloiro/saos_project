input {
  tcp {
    port => 514
    type => "syslog"
  }
  # Aggiungiamo anche file input per debug
  file {
    path => "/path/to/keycloak/standalone/log/server.log"  # Modifica questo percorso
    type => "keycloak"
    start_position => "beginning"
  }
}

filter {
  if [type] == "syslog" or [type] == "keycloak" {
    grok {
      match => {
        "message" => [
          # Pattern per eventi di login
          "type=%{WORD:event_type}\s+.*?userId=%{DATA:user_id}.*?clientId=%{DATA:client_id}.*?ipAddress=%{IP:ip_address}",
          # Pattern per eventi standard Keycloak
          "\[%{TIMESTAMP_ISO8601:timestamp}\]%{SPACE}%{WORD:level}%{SPACE}%{GREEDYDATA:message}",
          # Pattern per eventi di autenticazione
          ".*EVENT_TYPE\\?=%{WORD:event_type}.*USER_ID\\?=%{DATA:user_id}.*CLIENT_ID\\?=%{DATA:client_id}.*IP_ADDRESS\\?=%{IP:ip_address}"
        ]
      }
      tag_on_failure => ["_grokparsefailure"]
    }

    if "_grokparsefailure" in [tags] {
      # Log il messaggio non parsato per debug
      stdout { codec => rubydebug }
    }

    if [event_type] in ["LOGIN", "LOGOUT", "LOGIN_ERROR", "USER_LOGIN", "USER_LOGOUT"] {
      mutate {
        add_field => {
          "auth_event" => "true"
          "event_description" => "%{event_type} for user %{[user_id]} from IP %{[ip_address]}"
        }
      }
    }

    date {
      match => ["timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS"]
      target => "@timestamp"
      ignore_failure => true
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "keycloak-logs-%{+YYYY.MM.dd}"
  }
  # Output su file per debug
  file {
    path => "/tmp/logstash_debug.log"
    codec => rubydebug
  }
  stdout { codec => rubydebug }
}